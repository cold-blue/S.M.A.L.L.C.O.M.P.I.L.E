package background;
import java.io.*;
import java.util.*;

//import background.SimpleCompiler.symbol;

class Int {
	int value;
	Int (int valueOut) {
		value = valueOut;
	}
}

public class SimpleCompiler {
	
	static String pathOut = "ResultData/";
	static String fileOutputName = pathOut + "output.txt";
	static String fileInName = "";
	static String fileCodeName = pathOut + "code.txt";
	static String fileCodeListName = pathOut + "codelist.txt";
	static String fileTableName = pathOut + "table.txt";
	static String fileResultName = pathOut + "result.txt";
	static String fileStackName = pathOut + "stack.txt";
	
	//private final static int norw = 13; // key word number
	private final static int txmax = 100; // symbol table size
	private final static int nmax = 14; // max length of number
	//private final static int al = 10; // the max length of identifiers
	private final static int maxerr = 30; // the max number of errors
	private final static int amax = 500; // the max number of address
	private final static int levmax = 3; // the max number of levels
	private final static int cxmax = 300; // the max number of virtual machine codes
	private final static int stacksize = 500; // the max number of stack items
	//private final static int symnum = 43; // the max number of symbols
	
	// symbol value
	public enum symbol {
		nul, ident, number, plus, minus,
	// error, identifier, number, +, -, 
		times, slash, mod, oddsym, eql, neq,
	// *, /, %, ODD, ==, !=
		lss, leq, gtr, geq, lparen,
	// <, <=, >, >=, (
		rparen, comma, semicolon, period, becomes,
	// ), ,, ;, ., :=,
		beginsym, endsym, dosym, callsym, constsym,
	// begin, end, do, call, const
		repeatsym, untilsym, ifsym, elsesym, thensym,
	// repeat, until, if, else, then
		readsym, writesym, xorsym, switchsym, casesym,
	// read, write, xor, switch, case
		defaultsym, continuesym, breaksym, exitsym, arraysym,
	// default, continue, break, exit, array
		varsym, procsym, selfp, selfm, whilesym,
	// var, procedure, ++,--, while
		forsym, tosym, ofsym, colon, plus_self,
	// for, to, of, :, ++
		minus_self, itl, notsym, orsym, andsym
	// --, =, not, or, and
	};
	
	// identifier types
	private enum object {
		constant,
		variable,
		array,
		procedure,
		parameter
	};
	
	// virtual machine instruction
	private enum fct {
		lit, opr, lod,
		sto, cal, ini,
		jmp, jpc, ext,
		nul, jpb, dup,
		era
	};
	
	// virtual machine code construction
	private static class instruction {
		fct f; // virtual machine instruction
		int l; // the level gap of reference level and declaration level
		int a; // varies according to f
	}
	
	private static char ch; // the current char
	private static symbol sym; // the current symbol
	private static String id; // the current identifier
	private static int num; // the current number
	private static int cc, ll; // the current char, line length
	private static int cx; // virtual machine code pointer, range in [0, cxmax - 1]
	private static BufferedReader bufferedReader; // buffered reader used when reading file
	private static String line; //the line buffer
	private static int lineNum; // the line number of String in line buffer in file
	private static String a; // concurrent word
	private static instruction[] code = new instruction[cxmax]; // restore virtual machine code
	//private static String word; // key word
	private static HashMap<String, symbol> wsym;  // key: key word  value: symbol of the word
	private static HashMap<String, symbol> ssym; // key: single word  value: symbol
	private static HashMap<fct, String> mnemonic; // virtual machine instruction name
	private static HashSet<symbol> declbegsys; // declaration begin symbols
	private static HashSet<symbol> statbegsys; // statement begin symbols
	private static HashSet<symbol> facbegsys; // factor begin symbols
	private static boolean InLoop; // judge if continue or break instruction is in a loop stmt
	//private static boolean InCase; // judge if break instruction is in a case stmt
	private static HashSet<Integer> breakJmpSet = new HashSet<Integer>(); 
	// item: the index of jmp instruction generated by break in a loop or switch
	// when a loop or switch finish parsing, fill the adrs to it
	private static HashSet<Integer> continueJmpSet = new HashSet<Integer>(); 
	// item: the index of jmp instruction generated by continue in a loop
	// when a loop finish parsing, fill the adrs to it
	public static boolean listStackSwitch;
	
	private static class tablestruct
	{
		String name = null; // identifier name
		object kind; // identifier kind(constant, variable, array, procedure)
		int value; // number value, only for const
		int level; // level, not for const only
		int adr; // address, not for const only
		int size; // needed space, only for procedure
	};
	
	private static tablestruct[] table = new tablestruct[txmax]; // symbol table
	static FileReader fin; // input resource file
	static FileWriter foutput; // output file and error showing
	static FileWriter fcodelist; // target code list file
	static FileWriter fcode; // virtual machine code output
	static FileWriter fresult; // executing result output
	static FileWriter fstack; // stack file
	static FileWriter ftable; // symbol table output
	String fname; // file name
	static int err; // error count
	//static int ptx; // the final index in table
	//static int pdx; // the relative address of currently assigned variable, add 1 after assigning	
	// single instance mode

	
	protected static void initParse(String fin_name) throws IOException {
		fileInName = fin_name;
		
		foutput = new FileWriter(fileOutputName);
		fin = new FileReader(fileInName);
		ftable = new FileWriter(fileTableName);
		fcodelist = new FileWriter(fileCodeListName);
		fresult = new FileWriter(fileResultName);
		
		listStackSwitch = false;
		
		err = 0;
		cc = 0;
		ll = 0;
		cx = 0;
		lineNum = 0;
		bufferedReader = new BufferedReader(fin);
		
		ssym = new HashMap<String, symbol>();
		ssym.put("+", symbol.plus);
		ssym.put("-", symbol.minus);
		ssym.put("*", symbol.times);
		ssym.put("/", symbol.slash);
		ssym.put("%", symbol.mod);
		ssym.put("(", symbol.lparen);
		ssym.put(")", symbol.rparen);
		ssym.put(",", symbol.comma);
		ssym.put(":", symbol.colon);
		ssym.put(".", symbol.period);
		ssym.put(";", symbol.semicolon);
		
		wsym = new HashMap<String, symbol>();
		wsym.put("begin", symbol.beginsym);
		wsym.put("end", symbol.endsym);
		wsym.put("call", symbol.callsym);
		wsym.put("procedure", symbol.procsym);
		wsym.put("const", symbol.constsym);
		wsym.put("var", symbol.varsym);
		wsym.put("array", symbol.arraysym);
		wsym.put("while", symbol.whilesym);
		wsym.put("do", symbol.dosym);
		wsym.put("repeat", symbol.repeatsym);
		wsym.put("until", symbol.untilsym);
		wsym.put("for", symbol.forsym);
		wsym.put("if", symbol.ifsym);
		wsym.put("then", symbol.thensym);
		wsym.put("else", symbol.elsesym);
		wsym.put("read", symbol.readsym);
		wsym.put("write", symbol.writesym);
		wsym.put("ODD", symbol.oddsym);
		wsym.put("XOR", symbol.xorsym);
		wsym.put("OR", symbol.orsym);
		wsym.put("AND", symbol.andsym);
		wsym.put("NOT", symbol.notsym);
		wsym.put("switch", symbol.switchsym);
		wsym.put("case", symbol.casesym);
		wsym.put("of", symbol.ofsym);
		wsym.put("default", symbol.defaultsym);
		wsym.put("continue", symbol.continuesym);
		wsym.put("break", symbol.breaksym);
		wsym.put("exit", symbol.exitsym);
		
		mnemonic = new HashMap<fct, String>();
		mnemonic.put(fct.lit, "lit");
		mnemonic.put(fct.opr, "opr");
		mnemonic.put(fct.lod, "lod");
		mnemonic.put(fct.sto, "sto");
		mnemonic.put(fct.cal, "cal");
		mnemonic.put(fct.ini, "ini");
		mnemonic.put(fct.jmp, "jmp");
		mnemonic.put(fct.jpc, "jpc");
		mnemonic.put(fct.ext, "ext");
		
		
		declbegsys = new HashSet<symbol>();
		declbegsys.add(symbol.constsym);
		declbegsys.add(symbol.varsym);
		declbegsys.add(symbol.varsym);
		declbegsys.add(symbol.procsym);
		
		statbegsys = new HashSet<symbol>();
		statbegsys.add(symbol.beginsym);
		statbegsys.add(symbol.callsym);
		statbegsys.add(symbol.ifsym);
		statbegsys.add(symbol.whilesym);
		statbegsys.add(symbol.repeatsym);
		statbegsys.add(symbol.dosym);
		statbegsys.add(symbol.continuesym);
		statbegsys.add(symbol.breaksym);
		statbegsys.add(symbol.exitsym);
		statbegsys.add(symbol.readsym);
		statbegsys.add(symbol.writesym);
		statbegsys.add(symbol.forsym);
		statbegsys.add(symbol.switchsym);
		statbegsys.add(symbol.defaultsym);
		
		facbegsys = new HashSet<symbol>();
		facbegsys.add(symbol.ident);
		facbegsys.add(symbol.number);
		facbegsys.add(symbol.lparen);
		
		for (int i = 0; i < txmax; i ++) {
			table[i] = new tablestruct();
		}
		
		for (int i = 0; i < cxmax; i ++) {
			code[i] = new instruction();
		}
		
	}
	
	protected static void syntaxParserMain() throws IOException {
		getch();
		getsym();
		
		HashSet<symbol> nxtlev = addSet(declbegsys, statbegsys); // block begin symbols
		nxtlev.add(symbol.period);
		
		block(0, new Int(0), nxtlev);
		
		if (sym != symbol.period) {
			error(9, "there should be period");
		}
	}
	
	private static void error(int n, String errStr) throws IOException
	{
		int spaceCount = cc - 1;
		String space = "";
		for(int i = 0; i <= spaceCount; i ++) {
			space += " ";
		}
		foutput.write("line " + String.valueOf(lineNum) + ":\n");
		foutput.write(line + "\n");
		foutput.write(space + "^\n");
		foutput.write("error: " + String.valueOf(n) + " \n" + errStr + "\n");
		
		err += 1;
		if (err > maxerr) {
			System.exit(1);
		}
	}
	
	// get a char
	private static void getch() throws IOException {
		
		if (cc == ll) { // fetch a new line
			if ((line = bufferedReader.readLine()) == null) {
				foutput.write("Program is incomplete\n");
				ch = '\0';
				return;
			}
			ll = line.length();
			cc = 0;
			lineNum ++;
		}
		if (cc == ll) {
			System.out.println("symbol.nul");
			foutput.write("unfinished program!\n");
			ch = '\0';
			return;
		}
		ch = line.charAt(cc);
		cc ++;
	}
	
	// get a symbol value
	private static void getsym() throws IOException {
		if (ch == '\0') {
			sym = symbol.nul;
			System.out.println("symbol.nul");
			return;
		}
		// jump over all whitespace \n \t \r
		while (Character.isWhitespace(ch) || ch == '\n' ||
				ch == '\t' || ch == '\r') {
			getch();
		}
				
		if (ch == '#') { // annotation
			while (cc < ll) {
				getch();
			}
			getch();
			while (Character.isWhitespace(ch) || ch == '\n' ||
					ch == '\t' || ch == '\r') {
				getch();
			}
		}
		
		// the current word is an identifier or key word
		if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
			
			a = String.valueOf(ch);
			getch();
			while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
					(ch >= '0' && ch <= '9')) {
				a += String.valueOf(ch);
				getch();
			}
			
			id = a;
			
			// the current word is a key word
			if (wsym.containsKey(id)) {
				sym = wsym.get(id);
			}
			// the current word is an identifier
			else {
				sym = symbol.ident;
			}
		}
		// the current word is a number
		else if (ch >= '0' && ch <= '9') {
			int k = 1; // the length of the number
			sym = symbol.number;
			num = ch - '0';
			getch();
			while (ch >= '0' && ch <= '9') {
				num = 10 * num + ch - '0';
				k ++;
				getch();
			}
			
			if (k > nmax) {
				error(30, "the length of the number is too long");
			}
		}
		// the current word is :=
		else if (ch == ':') {
			getch();
			if (ch == '=') {
				sym = symbol.becomes;
				getch();
			}
			else {
				sym = symbol.colon;
			}
		}
		// the current word is !=
				else if (ch == '!') {
					getch();
					if (ch == '=') {
						sym = symbol.neq;
						getch();
					}
					else {
						sym = symbol.nul; // cannot identify the symbol
					}
				}
		// the current word is ==
				else if (ch == '=') {
					getch();
					if (ch == '=') {
						sym = symbol.eql;
						getch();
					}
					else {
						sym = symbol.itl; // cannot identify the symbol
					}
				}
		// the current word is < or <=
		else if (ch == '<') {
			getch();
			if (ch == '=') {
				sym = symbol.leq;
				getch();
			}
			else {
				sym = symbol.lss;
			}
		}
		// the current word is > or >=
		else if (ch == '>') {
			getch();
			if (ch == '=') {
				sym = symbol.geq;
				getch();
			}
			else {
				sym = symbol.gtr;
			}
		}
		else if (ch == '+') {
			getch();
			if (ch == '+') {
				sym = symbol.plus_self;
				getch();
			}
			else {
				sym = symbol.plus;
			}
		}
		else if (ch == '-') {
			getch();
			if (ch == '-') {
				sym = symbol.minus_self;
				getch();
			}
			else {
				sym = symbol.minus;
			}
		}
		// the current word is a single word
		else {
			sym = ssym.get(String.valueOf(ch));
			if (sym != symbol.period) {
				getch();
			}
		}
		
	}
	
	// test the current symbol is legal or not
	//private static void test()
	
	// add two sets
	private static HashSet<symbol> addSet(HashSet<symbol> set1, HashSet<symbol> set2) {
		HashSet<symbol> resultSet = new HashSet<symbol>();
		resultSet.addAll(set1);
		resultSet.addAll(set2);
		return resultSet;
	}
	
	// set1 sub set2
//	private static HashSet<symbol> subSet(HashSet<symbol> set1, HashSet<symbol> set2) {
//		HashSet<symbol> resultSet = new HashSet<symbol>();
//		resultSet.addAll(set1);
//		resultSet.removeAll(set2);
//		return resultSet;
//	}
	
	// mul two sets
//	private static HashSet<symbol> mulSet(HashSet<symbol> set1, HashSet<symbol> set2) {
//		HashSet<symbol> resultSet = new HashSet<symbol>();
//		resultSet.addAll(set1);
//		resultSet.retainAll(set2);
//		return resultSet;
//	}
	
	// add one into table
	private static void enter(object k, Int ptx, int lev, Int pdx) throws IOException {
		
		ptx.value ++;
		table[ptx.value].name = id;
		table[ptx.value].kind = k;
		switch(k) {
		case constant:
			if (num > amax) {
				error(31, "the length of the number is too long");
				num = 0;
			}
			table[ptx.value].value = num;
			break;
		case variable:
			table[ptx.value].level = lev;
			table[ptx.value].adr = pdx.value;
			pdx.value ++;
			break;
		case procedure:
			table[ptx.value].level = lev;
			break;
		default:
			break;
		}

	}
	
	// find the place of id in symbol table
	private static int position (String id, Int tx) {
		
		int i;
		table[0].name = id;
		i = tx.value;
		while (!table[i].name.equals(id)) {
			i --;
		}
		return i;
	}
	
	// constant declaration processing
	private static void constdeclaration(Int ptx, int lev, Int pdx) throws IOException {
		
		if (sym == symbol.ident) {
			getsym();
			if (sym == symbol.itl || sym == symbol.becomes) {
				if (sym == symbol.becomes) {
					error(1, "code = wrong to :=");
				}
				getsym();
				if (sym == symbol.number) {
					enter(object.constant, ptx, lev, pdx);
					getsym();
				}
				else {
					error(2, "in const declaration, there should be number after ="); 
				}
			}
			else {
				error(3, "in const declaration, there should be = after identifier"); 
			}
		}
		else {
			error(4, "in const declaration, there should be identifier after const");
		}
	}
	
	// variable declaration process
	private static void vardeclaration(Int ptx, int lev, Int pdx) throws IOException {
		
		if (sym == symbol.ident) {
			enter(object.variable, ptx, lev, pdx);
			getsym();
		}
		else {
			error(4, "there should be identifier after var");
		}
	}
	
	// output target codes list into fcodelist
	static void listcode(int cx0) throws IOException {
		int i;
		// if (listswitch) ...
		
		fcodelist.write("\n");
		for (i = cx0; i < cx; i ++) {
			String str = String.valueOf(i) + " " +
					mnemonic.get(code[i].f) + " " +
					String.valueOf(code[i].l) + "\n";
			fcodelist.write(str);
		}
	}
	
	// output stack list into fstack
		static void liststack(int t, int s[]) throws IOException {
			int i;
			// if (listswitch) ...
			fstack = new FileWriter(fileStackName);
			
			//fstack.write("\n");
			for (i = 0; i <= t; i ++) {
				String str = String.valueOf(i) + "    " +
						String.valueOf(s[i]) + "\n";
				fstack.write(str);
			}
			fstack.close();
		}
	
	// output all target codes
	static void listall() throws IOException {
		int i;
		fcode = new FileWriter(fileCodeName);
		
		for (i = 0; i < cx; i ++) {
			String fileStr = String.valueOf(i) + "  " + String.valueOf(code[i].f) + 
					"  " + String.valueOf(code[i].l) + "  " + String.valueOf(code[i].a);
			System.out.println(fileStr);
			fcode.write(fileStr + "\n");
		}
	}
	
	// generate virtual machine code
	private static void gen(fct x, int y, int z) throws IOException {
		if (cx >= cxmax) {
			System.out.println("Program is too long!");
			foutput.write("Program is too long!");
			System.exit(1);
		}
		if (z >= amax) {
			System.out.println("Displacement address is too long!");
			foutput.write("Displacement address is too long!");
			System.exit(1);
		}
		code[cx].f = x;
		code[cx].l = y;
		code[cx].a = z;
		cx ++;
	}
	
	// test that the current symbol is in the needing set or not
	// if not jump to a place were the symbol is in the needing set or supplementary set
	private static void test(HashSet<symbol> s1, HashSet<symbol> s2, int n) throws IOException {
		if (!s1.contains(sym)) {
			error(n, "");
			if (sym == symbol.nul) {
				return;
			}
			while ((!s1.contains(sym)) && (!s2.contains(sym))) {
				getsym(); // jump over the wrong part
			}
		}
	}
	
	// block parse
	@SuppressWarnings("unchecked")
	private static void block(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		Int dx = new Int(0); // the relative address of data assigning
		int tx0; // the initial tx
		int cx0; // the initial cx
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone(); // the begin symbol sets of block
		
		dx.value = 3; // 0 for static chain SL, 1 for dynamic chain DL, return address RA
		tx0 = tx.value; // record the initial position of identifiers in this level
		table[tx.value].adr = cx; // record the initial position of code in this level
		gen(fct.jmp, 0, 0); // generate jump instruction, 
		// since we don't know the jump address, set it 0
		
		if (lev > levmax) {
			error(32, "too many embedding levels"); 
		}
		
		do {
			if (sym == symbol.constsym) { // constants declaration
				getsym();
				boolean IsSemiOccurred = false;
				
				do {
					if (IsSemiOccurred == true) {
						error(5, "take , wrong to ;");
						IsSemiOccurred = false;
					}
					constdeclaration(tx, lev, dx);
					// the value of dx will be changed by the method
					while (sym == symbol.comma) { 
						// continue defining constants when meeting comma
						getsym();
						constdeclaration(tx, lev, dx);
					}
					if (sym == symbol.semicolon) {
						IsSemiOccurred = true;
						// finish defining constants when meeting semicolon
						getsym();
					}
					else {
						error(5, "miss semicolon");
					}
				} while (sym == symbol.ident);
				IsSemiOccurred = false;
			}
			
			if (sym == symbol.varsym) { // variables declaration
				getsym();
				boolean IsSemiOccurred = false;
				
				do {
					if (IsSemiOccurred == true) {
						error(5, "take , wrong to ;");
						IsSemiOccurred = false;
					}
					vardeclaration(tx, lev, dx);
					// the value of dx will be changed by the method
					while (sym == symbol.comma) { 
						// continue defining constants when meeting comma
						getsym();
						vardeclaration(tx, lev, dx);
					}
					if (sym == symbol.semicolon) {
						IsSemiOccurred = true;
						// finish defining constants when meeting semicolon
						getsym();
					}
					else {
						error(5, "miss semicolon");
					}
				} while (sym == symbol.ident);
				IsSemiOccurred = false;
			}
			
			while (sym == symbol.procsym) { // procedures declaration
				getsym();
				
				if (sym == symbol.ident) {
					enter(object.procedure, tx, lev, dx); // enter symbol table
					getsym();
				}
				else {
					error(4, "there should be identifier after procedure");
				}
				
				if (sym == symbol.semicolon) {
					getsym();
				}
				else {
					error(5, "miss semicolon"); 
				}
				
				nxtlev = (HashSet<symbol>) fsys.clone();
				nxtlev.add(symbol.semicolon);
				block(lev + 1, tx, nxtlev);
				
				if (sym == symbol.semicolon) {
					getsym();
					nxtlev = (HashSet<symbol>) statbegsys.clone();
					nxtlev.add(symbol.ident);
					nxtlev.add(symbol.procsym);
					test(nxtlev, fsys, 6);
				}
				else {
					error(5, "miss semicolon");
				}
			}
			nxtlev = (HashSet<symbol>) statbegsys.clone();
			nxtlev.add(symbol.ident);
			test(nxtlev, declbegsys, 7);
		} while (declbegsys.contains(sym)); //  until there is no declaration
		
		code[table[tx0].adr].a = cx; 
		// change the jump address of previously generated jump instruction to cs
		table[tx0].adr = cx;
		// record the code address of current procedure
		table[tx0].size = dx.value;
		// in declaration part, dx.value + 1 every time when adding a declaration 
		// now this part has finished, and dx.value is the size of data
		cx0 = cx;
		gen(fct.ini, 0, dx.value);
		// generate instruction, when ini instruction executing for opening
		// dx units of data space
		
		ftable = new FileWriter(fileTableName); 
		// if(tableswitch)
		for (int i = 1; i <= tx.value; i ++) {
			switch (table[i].kind) {
			case constant:
				ftable.write(String.valueOf(i) + " const " +
						table[i].name + " val=" + 
						String.valueOf(table[i].value) + "\n");
				break;
			case variable:
				ftable.write(String.valueOf(i) + 
						" var " + table[i].name + 
						" lev=" + String.valueOf(table[i].level) +
						" addr=" + String.valueOf(table[i].adr) + "\n");
				break;
			case procedure:
				ftable.write(String.valueOf(i) + 
						" proc " + table[i].name + 
						" lev=" + String.valueOf(table[i].level) +
						" addr=" + String.valueOf(table[i].adr) +
						" size=" + String.valueOf(table[i].size) + "\n");
				break;
			default:
				ftable.write("wrong kind\n");
			}
			ftable.write("\n");
		}
		
		nxtlev = (HashSet<symbol>) fsys.clone();
		nxtlev.add(symbol.semicolon);
		nxtlev.add(symbol.endsym);
		
		statement(lev, tx, nxtlev);
		gen(fct.opr, 0, 0); 
		// release data segment instruction should be used at every procedure exit
		nxtlev.clear(); // sub program has no supplementary set
		test(fsys, nxtlev, 8);
		listcode(cx0);
	}
	
	//statement parse
	private static void statement(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		
		if (sym == symbol.ident || sym == symbol.plus_self || sym == symbol.minus_self) {
			assign_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.readsym) {
			read_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.writesym) {
			write_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.callsym) {
			call_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.ifsym) {
			if_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.exitsym) {
			exit_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.beginsym) {
			begin_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.repeatsym) {
			repeat_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.whilesym) {
			while_do_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.dosym) {
			do_while_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.repeatsym) {
			repeat_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.forsym) {
			for_stmt(lev, tx, fsys);
		}
		else if (sym == symbol.breaksym) {
			if (InLoop == false) { // && InCase == false
				error(102, "break should be in loop or case");
			}
			else {
				breakJmpSet.add(cx);
				gen(fct.jmp, 0, 0);
			}
			getsym();
		}
		else if (sym == symbol.continuesym) {
			if (InLoop == false) {
				error(102, "continue should be in loop");
			}
			else {
				continueJmpSet.add(cx);
				gen(fct.jmp, 0, 0);
			}
			getsym();
		}
		else if (sym == symbol.casesym) {
			case_stmt(lev, tx, fsys);
		}
	}
	
	// switch statement
	@SuppressWarnings("unchecked")
	private static void case_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone();
		HashSet<Integer> jmpSet = new HashSet<Integer>();
		int cx2 = -1;
		//int cx1;
		int i;
		int value = 0; // the value of constant
		
		getsym();
		nxtlev.add(symbol.ofsym);
		//cx1 = cx; // store the starting code index of expression
		expression(lev, tx, nxtlev);
		if (sym == symbol.ofsym) {
			getsym();
		}
		else {
			error(106, "miss of");
		}
		
		while (sym == symbol.ident || sym == symbol.number) {
			if (sym == symbol.ident) {
				i = position(id, tx);
				if (i == 0) {
					error(107, "identifier undeclared");
				}
				else {
					if (table[i].kind != object.constant) {
						error(108, "in case stmt, ident should be constant");
					}
					else {
						value = table[i].value;
					}
				}
				
			}
			
			if (sym == symbol.number) {
				value = num;
			}
			getsym();
			
			if (cx2 != -1) {
				code[cx2].a = cx;
			}
			gen(fct.dup, 0, 0);
			gen(fct.lit, 0, value);
			gen(fct.opr, 0, 8); // is the two value equal?
			cx2 = cx;
			gen(fct.jpc, 0, 0);
			
			if (sym == symbol.colon) {
				getsym();
			}
			else {
				error(109, "miss colon");
			}
			
			nxtlev.remove(symbol.ofsym);
			//nxtlev.add(symbol.endsym);
			statement(lev, tx, nxtlev);
			jmpSet.add(cx);
			gen(fct.jmp, 0, 0);

		}
		
		code[cx2].a = cx;
				
		if (sym == symbol.elsesym) {
			getsym();
		if (sym == symbol.colon) {
			getsym();
		}
		else {
			error(109, "miss colon");
		}
			nxtlev.add(symbol.endsym);
			statement(lev, tx, nxtlev);
		}
		else {
			gen(fct.nul, 0, 0);
		}
		
		if (sym == symbol.endsym) {
			getsym();
		}
		else {
			error(110, "miss end");
		}
		
		for (Integer ind: jmpSet) {
			code[ind].a = cx;
		}
		gen(fct.era, 0, 0); // erase the top value in the stack that generated by expression
	}
	
	// for statement
	@SuppressWarnings("unchecked")
	private static void for_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = null;
		int cx1 = -1, cx2 = -1, cx3;
		
		InLoop = true;
		getsym();
		if (sym == symbol.lparen) {
			getsym();
		}
		else {
			error(104, "miss lparen");
		}
		
		if (sym == symbol.ident || sym == symbol.plus_self || sym == symbol.minus_self) {
			assign_stmt(lev, tx, fsys);
		}
		
		if (sym == symbol.semicolon) {
			getsym();
		}
		else {
			error(105, "miss semicolon");
		}
		nxtlev = (HashSet<symbol>) fsys.clone();
		nxtlev.add(symbol.semicolon);
		
		cx1 = cx; // store the starting code index of expression
		if (sym == symbol.oddsym || facbegsys.contains(sym)) {
			expression(lev, tx, fsys);
		}
		else {
			error(106, "there should be expression after the 1st semicolon");
			gen(fct.nul, 0, 0);
		}
		cx3 = cx; // store the starting code index of jmp
		gen(fct.jpb, 0, 0);
		
		if(sym == symbol.semicolon) {
			getsym();
		}
		else {
			error(105, "miss semicolon");
		}
		
		nxtlev.add(symbol.rparen);
		cx2 = cx; // store the starting code index of assign_stmt
		if (sym == symbol.ident || sym == symbol.plus_self || sym == symbol.minus_self) {
			assign_stmt(lev, tx, nxtlev);
		}
		else {
			gen(fct.nul, 0, 0);
		}
		if (sym == symbol.rparen) {
			getsym();
		}
		else {
			error(116, "there should be ( after assign_stmt");
		}
		gen(fct.jmp, 0, cx1);
		
		code[cx3].l = cx;
		statement(lev, tx, fsys);
		gen(fct.jmp, 0, cx2);
		
		code[cx3].a = cx;
		if (!breakJmpSet.isEmpty()) {
			for (Integer ind: breakJmpSet) {
				code[ind].a = cx;
			}
		}
		
		if (!continueJmpSet.isEmpty()) {
			for (Integer ind: continueJmpSet) {
				code[ind].a = cx2;
			}
		}
		breakJmpSet.clear();
		continueJmpSet.clear();
		InLoop = false;
	}
	
	// repeat statement
	private static void repeat_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		@SuppressWarnings("unchecked")
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone();
		int cx1, cx2;
		
		InLoop = true;
		getsym();
		cx1 = cx; // store the starting code index of statement
		nxtlev.add(symbol.untilsym);
		statement(lev, tx, nxtlev);
		if (sym == symbol.untilsym) {
			getsym();
		}
		else {
			error(18, "miss do");
		}
		cx2 = cx; // store the starting code index of expression
		expression(lev, tx, fsys);
		gen(fct.jpc, 0, cx1);

		if (!breakJmpSet.isEmpty()) {
			for (Integer ind: breakJmpSet) {
				code[ind].a = cx;
			}
		}
		
		if (!continueJmpSet.isEmpty()) {
			for (Integer ind: continueJmpSet) {
				code[ind].a = cx2;
			}
		}
		breakJmpSet.clear();
		continueJmpSet.clear();
		InLoop = false;
	}
	
	// do while statement
	private static void do_while_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		@SuppressWarnings("unchecked")
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone();
		int cx1, cx2;
		
		InLoop = true;
		getsym();
		cx1 = cx; // store the starting code index of statement
		nxtlev.add(symbol.whilesym);
		statement(lev, tx, nxtlev);
		if (sym == symbol.semicolon) {
			error(118, "there should not be ;");
			getsym();
		}
		if (sym == symbol.whilesym) {
			getsym();
		}
		else {
			error(18, "miss while");
		}
		cx2 = cx; // store the starting code index of expression
		expression(lev, tx, fsys);
		gen(fct.jpc, 1, cx1);

		if (!breakJmpSet.isEmpty()) {
			for (Integer ind: breakJmpSet) {
				code[ind].a = cx;
			}
		}
		
		if (!continueJmpSet.isEmpty()) {
			for (Integer ind: continueJmpSet) {
				code[ind].a = cx2;
			}
		}
		breakJmpSet.clear();
		continueJmpSet.clear();
		InLoop = false;
	}
	
	// while do statement
	private static void while_do_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		@SuppressWarnings("unchecked")
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone();
		int cx1, cx2;
		
		InLoop = true;
		getsym();
		cx1 = cx; // store the starting code index of expression
		nxtlev.add(symbol.dosym);
		expression(lev, tx, nxtlev);
		cx2 = cx; // store the starting code index of jpc
		gen(fct.jpc, 0, 0);
		
		if (sym == symbol.dosym) {
			getsym();
		}
		else {
			error(18, "miss do");
		}
		
		statement(lev, tx, fsys);
		gen(fct.jmp, 0, cx1);
		
		code[cx2].a = cx;
		if (!breakJmpSet.isEmpty()) {
			for (Integer ind: breakJmpSet) {
				code[ind].a = cx;
			}
		}
		
		if (!continueJmpSet.isEmpty()) {
			for (Integer ind: continueJmpSet) {
				code[ind].a = cx1;
			}
		}
		breakJmpSet.clear();
		continueJmpSet.clear();
		InLoop = false;
	}
	
	// begin end statement
	private static void begin_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		@SuppressWarnings("unchecked")
		HashSet<symbol> nxtlev = (HashSet<symbol>) fsys.clone();
		
		getsym();
		nxtlev.add(symbol.semicolon);
		nxtlev.add(symbol.endsym);
		statement(lev, tx, nxtlev);
		while (statbegsys.contains(sym) || sym == symbol.semicolon) {
			if (sym == symbol.semicolon) {
				getsym();
			}
			else {
				error(10, "miss semicolon");
			}
			statement(lev, tx, nxtlev);
		}
		
		if (sym == symbol.endsym) {
			getsym();
		}
		else {
			error(17, "miss end");
		}
	}
	
	// call statement(TO CHANGE)
	private static void exit_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		@SuppressWarnings("unchecked")
		HashSet<symbol> nxtlev = (HashSet<symbol>) statbegsys.clone();
		nxtlev.add(symbol.rparen);
		nxtlev.add(symbol.semicolon);
		
		getsym();
		if (sym != symbol.lparen) {
			error(100, "there should be lapren after exit");
		}
		else {
			getsym();
			simple_exp(lev, tx, nxtlev);
			if (sym == symbol.rparen) {
				getsym();
			}
			else {
				error(101, "miss rparen");
			}
		}
		gen(fct.opr, 0, 0); // fetch the value at the top of stack as exit value and print it
	}
	
	// if statement(TO CHANGE)
	@SuppressWarnings("unchecked")
	private static void if_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		int cx1; // store the address of current instruction
		
		getsym();
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev.add(symbol.thensym);
		nxtlev.add(symbol.dosym);
		expression(lev, tx, nxtlev);
		if (sym == symbol.thensym) {
			getsym();
		}
		else {
			error(16, "miss then");
		}
		cx1 = cx; // store the current instruction(jpc) address
		gen(fct.jpc, 0, 0);
		nxtlev = (HashSet<symbol>) fsys.clone();
		nxtlev.add(symbol.elsesym);
		nxtlev.add(symbol.endsym);
		statement(lev, tx, nxtlev);
		code[cx1].a = cx;
		
		if (sym == symbol.elsesym) {
			getsym();
			gen(fct.jmp, 0, 0); // cx automatically add 1
			code[cx1].a = cx; // change the jpc address
			cx1 = cx - 1; // store the current instruction(jmp) address
			nxtlev.remove(symbol.elsesym);
			statement(lev, tx, nxtlev);
			code[cx1].a = cx; // fill the adr of jmp instruction
		}
		
		if (sym == symbol.endsym) {
			getsym();
		}
		else {
			error(110, "miss end");
		}
	}
	
	// expression
	@SuppressWarnings("unchecked")
	private static void expression(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev = (HashSet<symbol>) fsys.clone();
		
		nxtlev.add(symbol.orsym);
		cond_exp(lev, tx, nxtlev);
		
		while (sym == symbol.orsym) {
			getsym();
			cond_exp(lev, tx, nxtlev);
			gen(fct.opr, 0, 20);
		}
	}
	
	// condition expression
	@SuppressWarnings("unchecked")
	private static void cond_exp(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev = (HashSet<symbol>) fsys.clone();
		
		nxtlev.add(symbol.andsym);
		cond_exp2(lev, tx, nxtlev);
		
		while (sym == symbol.andsym) {
			getsym();
			cond_exp2(lev, tx, nxtlev);
			gen(fct.opr, 0, 19);
		}
	}
	
	@SuppressWarnings("unchecked")
	private static void cond_exp2(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev = (HashSet<symbol>) fsys.clone();
		
		nxtlev.add(symbol.xorsym);
		cond_exp3(lev, tx, nxtlev);
		
		while (sym == symbol.xorsym) {
			getsym();
			cond_exp3(lev, tx, nxtlev);
			gen(fct.opr, 0, 18);
		}
	}
	
	@SuppressWarnings("unchecked")
	private static void cond_exp3(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev = (HashSet<symbol>) fsys.clone();
		
		if (sym == symbol.notsym) {
			getsym();
			cond_exp4(lev, tx, nxtlev);
			gen(fct.opr, 0, 21);
		}
		else {
			cond_exp4(lev, tx, nxtlev);
		}
	}
	
	@SuppressWarnings("unchecked")
	private static void cond_exp4(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = new HashSet<symbol>();
		nxtlev = (HashSet<symbol>) fsys.clone();
		HashSet<symbol> compareSet = new HashSet<symbol>();
		symbol relop;
		
		if (sym == symbol.oddsym) {
			getsym();
			simple_exp(lev, tx, fsys);
			gen(fct.opr, 0, 6);
		}
		else {
			compareSet.add(symbol.eql);
			compareSet.add(symbol.neq);
			compareSet.add(symbol.lss);
			compareSet.add(symbol.leq);
			compareSet.add(symbol.gtr);
			compareSet.add(symbol.geq);
			nxtlev.addAll(compareSet);
			
			simple_exp(lev, tx, nxtlev);
			
			if (!compareSet.contains(sym)) {
				error(20, "there should be compare operation");
			}
			else {
				relop = sym;
				getsym();
				simple_exp(lev, tx, fsys);
				switch (relop) {
				case eql:
					gen(fct.opr, 0, 8);
					break;
				case neq:
					gen(fct.opr, 0, 9);
					break;
				case lss:
					gen(fct.opr, 0, 10);
					break;
				case geq:
					gen(fct.opr, 0, 11);
					break;
				case gtr:
					gen(fct.opr, 0, 12);
					break;
				case leq:
					gen(fct.opr, 0, 13);
					break;
				default:
					break;
				}
			}
		}
	}
	
	// call statement(TO CHANGE)
	private static void call_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		int i = 0;
		
		getsym();
		if (sym != symbol.ident) {
			error(14, "there should be identifier after call");
		}
		else {
			i = position(id, tx);
			if (i == 0) {
				error(11, "cannot find procedure name");
			}
			else {
				if (table[i].kind == object.procedure) {
					gen(fct.cal, lev - table[i].level, table[i].adr); // generate call instruction
				}
				else {
					error(15, "there should be procedure after call");
				}
			}
			getsym();
		}
		
		// TO DO(parameters)
//		if (sym == symbol.rparen) {
//			getsym();
//		}
	}
	
	// write statement
	@SuppressWarnings("unchecked")
	private static void write_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		HashSet<symbol> nxtlev = null;
		
		getsym();
		if (sym == symbol.lparen) {
			do {
				getsym();
				nxtlev = (HashSet<symbol>) fsys.clone();
				nxtlev.add(symbol.rparen);
				nxtlev.add(symbol.comma);
				simple_exp(lev, tx, nxtlev); // TO CHANGE
				gen(fct.opr, 0, 14); // output the value of the top of stack
				gen(fct.opr, 0, 15); // generate the change line instruction
				
			} while (sym == symbol.comma);
			if (sym != symbol.rparen) {
				error(33, "wrong format, there should be rparen");
			}
			else {
				getsym();
			}
		}
	}
	
	// read statement
	private static void read_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		int i;
		getsym();
		if (sym != symbol.lparen) {
			error(34, "wrong format, there should be (");
		}
		else {
			do {
				getsym();
				if (sym == symbol.ident) {
					i = position(id, tx);
				}
				else {
					i = 0;
				}
				
				if (i == 0) {
					error(35, "the identifier in the parenthesis should be declared variable"); 
				}
				else {
					gen(fct.opr, 0, 16); // generate input instruction, read till the top of stack
					gen(fct.sto, lev-table[i].level, table[i].adr); 
					// store the value at the top of stack into the variable
				}
				getsym();
			} while (sym == symbol.comma); // one read statement can read many variables
		}
		if (sym != symbol.rparen) {
			error(33, "wrong format, should be right rparen");
			while (!fsys.contains(sym)) {
				getsym(); // read until occurring the following symbol of last level function
			}
		}
		else {
			getsym();
		}
	}
	
	// assign statement
	@SuppressWarnings("unchecked")
	private static void assign_stmt(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		int i;
		HashSet<symbol> nxtlev = null;
		symbol self_op = null;
		
		if (sym == symbol.plus_self || sym == symbol.minus_self) {
			self_op = sym;
			getsym();
			if (sym != symbol.ident) {
				error(115, "there should be identifier");
			}
		}
		
		i = position(id, tx);
		if (i == 0) {
			error(11, "the identifier is not defined yet");
		}
		else {
			if (table[i].kind != object.variable) {
				error(12, "in assign statement, in left of = should be variable");
				i = 0;
			}
			else {
				getsym();
				if (sym == symbol.becomes) {
					getsym();
					nxtlev = (HashSet<symbol>) fsys.clone();
					simple_exp(lev, tx, nxtlev);
					// expression execute series of instructions
					// the final result will be stored in the top of the stack
					// execute the sto instruction complete assigning
					if (self_op != null) {
						error(114, "there should not be ++ or â€” after ident:=");
					}
				}
				else {
					if (self_op == null && sym != symbol.plus_self && sym != symbol.minus_self) {
						error(13, "didn't detect the assign symbol");
					}
					else {
						gen(fct.lod, lev - table[i].level, table[i].adr);
						gen(fct.lit, 0, 1);
						if (self_op != null) {
							if (self_op == symbol.plus_self) {
								gen(fct.opr, 0, 2);
							}
							else {
								gen(fct.opr, 0, 3);
							}
							if (sym == symbol.plus_self || sym == symbol.minus_self) {
								error(113, "there should not be ++ or - -  after ++\\- - ident");
								getsym();
							}
						}
						else {
							if (sym == symbol.plus_self) {
								gen(fct.opr, 0, 2);
							}
							else {
								gen(fct.opr, 0, 3);
							}
							getsym();
						}
					}
				}
				
				gen(fct.sto, lev - table[i].level, table[i].adr);
			}
		}
	}
	
	// simple expression
	@SuppressWarnings("unchecked")
	private static void simple_exp(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		symbol addop; // store +/- symbol
		HashSet<symbol> nxtlev;
		
		if (sym == symbol.plus || sym == symbol.minus) {
			// there is + or - at the start of expression
			addop = sym;
			getsym();
			nxtlev = (HashSet<symbol>) fsys.clone();
			nxtlev.add(symbol.plus);
			nxtlev.add(symbol.minus);
			term(lev, tx, nxtlev);
			if (addop == symbol.minus) {
				gen(fct.opr, 0, 1); // generate negation instrcution
			}
		}
		else { // can be regarded as terms plus or subtract
			nxtlev = (HashSet<symbol>) fsys.clone();
			nxtlev.add(symbol.plus);
			nxtlev.add(symbol.minus);
			term(lev, tx, nxtlev);
		}
		while (sym == symbol.plus || sym == symbol.minus) {
			addop = sym;
			getsym();
			nxtlev = (HashSet<symbol>) fsys.clone();
			nxtlev.add(symbol.plus);
			nxtlev.add(symbol.minus);
			term(lev, tx, nxtlev);
			if (addop == symbol.plus) {
				gen(fct.opr, 0, 2); // plus instruction
			}
			else {
				gen(fct.opr, 0, 3); // subtract instruction
			}
		}
	}
	
	// term
	@SuppressWarnings("unchecked")
	private static void term(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		symbol mulop;
		HashSet<symbol> nxtlev;
		
		nxtlev = (HashSet<symbol>) fsys.clone();
		nxtlev.add(symbol.times);
		nxtlev.add(symbol.slash);
		nxtlev.add(symbol.mod);
		factor(lev, tx, nxtlev);
		while (sym == symbol.times || sym == symbol.slash || sym == symbol.mod) {
			mulop = sym;
			getsym();
			factor(lev, tx, nxtlev);
			if (mulop == symbol.times) {
				gen(fct.opr, 0, 4); // multiple instruction
			}
			else if (mulop == symbol.slash){
				gen(fct.opr, 0, 5); // division instruction
			}
			else {
				gen(fct.opr, 0, 17); // mod instruction
			}
		}
	}
	
	// factor
	@SuppressWarnings("unchecked")
	private static void factor(int lev, Int tx, HashSet<symbol> fsys) throws IOException {
		int i;
		HashSet<symbol> nxtlev = (HashSet<symbol>) facbegsys.clone();
		nxtlev.add(symbol.plus_self);
		nxtlev.add(symbol.minus_self);
		test(nxtlev, fsys, 24); // detect the starting symbol of factor
		
		while (facbegsys.contains(sym) || sym == symbol.plus_self ||
				sym == symbol.minus_self) { // process factors recursively
			if (sym == symbol.plus_self || sym == symbol.minus_self) {
				symbol opr_self = sym;
				getsym();
				if (sym != symbol.ident) {
					error(112, "there should be variable after ++ or --");
				}
				else {
					i = position(id, tx);
					if (i == 0) {
						error(11, "identifier is not declared");
					}
					else {
						if (table[i].kind != object.variable) {
							error(112, "there must be variable for ++ or --");
						}
						else {
							gen(fct.lod, lev - table[i].level, table[i].adr);
							gen(fct.lit, 0, 1);
							if (opr_self == symbol.plus_self) {
								gen(fct.opr, 0, 2);
							}
							else { // minus_self
								gen(fct.opr, 0, 3);
							}
							gen(fct.sto, lev - table[i].level, table[i].adr);
							gen(fct.lod, lev - table[i].level, table[i].adr);
						}
					}
				}
			}
			else {
				
				if (sym == symbol.ident) { // factor is variable or constant
					i = position(id, tx);
					if (i == 0) {
						error(11, "identifier is not declared");
					}
					else {
						switch(table[i].kind) {
						case constant:
							gen(fct.lit, 0, table[i].value); // insert the constant into stack
							break;
						case variable:
							gen(fct.lod, lev - table[i].level, table[i].adr); 
							// find the variable address and insert it into stack
							break;
						case procedure:
							error(21, "cannot be procedure"); 
							break;
						default:
							break;
						}
					}
					getsym();
					
					if (sym == symbol.plus_self || sym == symbol.minus_self) {
						if (i != 0) {
							if (table[i].kind != object.variable) {
								error(112, "there must be variable for ++ or --");  
							}
							else {
								gen(fct.lod, lev - table[i].level, table[i].adr);
								gen(fct.lit, 0, 1);
								if (sym == symbol.plus_self) {
									gen(fct.opr, 0, 2);
								}
								else { // minus_self
									gen(fct.opr, 0, 3);
								}
								gen(fct.sto, lev - table[i].level, table[i].adr);
							}
						}
						getsym();
					}
				}
				else {
					
					if (sym == symbol.number) {
						if (num > amax) {
							error(31, "number exceeds");  
							num = 0;
						}
						gen(fct.lit, 0, num);
						getsym();
					}
					else {
						if (sym == symbol.lparen) {
							getsym();
							nxtlev = (HashSet<symbol>) fsys.clone();
							nxtlev.add(symbol.rparen);
							simple_exp(lev, tx, nxtlev);
							if (sym == symbol.rparen) {
								getsym();
							}
							else {
								error(22, "miss rparen"); 
							}
						}
					}
					if (sym == symbol.plus_self || sym == symbol.minus_self) {
						error(111, "there should not be plus_self or"
								+ " minus_self after number and (exp)"); 
						getsym();
					}
				}
			}
			
			nxtlev.clear();
			nxtlev.add(symbol.lparen);
			test(fsys, nxtlev, 23);
		}
	}
	
	// interpret
	static int p = 0; // instruction pointer
	static int b = 1; // instruction base address
	static int t = 0; // stack top pointer
	static int[] s = new int[stacksize];
	static instruction i; // the current instruction
	
	protected static void interpret() throws IOException {	
		
		System.out.println("Start Interpreting!");
		//foutput.write("Start Interpreting!\n");
		fresult.write("Start Interpreting!\n");
		s[0] = 0; // useless
		s[1] = 0; //SL the s index of static previous procedure
		s[2] = 0; //DL the s index of dynamic previous procedure
		s[3] = 0; //RA the code index of next instruction
		do {
			interpretOneInstruction();
		} while (p != 0);
		System.out.println("End interpreting.");
		fresult.write("End interpreting.\n");
	}
	
	// get the base address of previous l levels procedure
	private static int base(int l, int[] s, int b) {
		int b1;
		
		b1 = b;
		while (l > 0) {
			b1 = s[b1];
			l --;
		}
		return b1;
	}
	
	protected static boolean isInterpretOver() {
		if (p == 0)
			return true;
		else
			return false;
	}
	
	protected static void initStepInterpret() throws IOException {
		listStackSwitch = true;
		p = 0; // instruction pointer
		b = 1; // instruction base address
		t = 0;
		Arrays.fill(s, 0);
		s[0] = 0; // useless
		s[1] = 0; //SL the s index of static previous procedure
		s[2] = 0; //DL the s index of dynamic previous procedure
		s[3] = 0; //RA the code index of next instruction
		fresult = new FileWriter(fileResultName);
	}
	
	protected static String getInstructionStr() {
		String InstruStr = String.valueOf(p - 1) + "  " + String.valueOf(i.f) + "  " +
				String.valueOf(i.l) + "  " + String.valueOf(i.a);
		return InstruStr;
	}
	
	protected static void interpretOneInstruction() throws IOException {
		i = code[p]; // read the current instruction
		p ++;
		switch (i.f) {
		case lit: // fetch the constant to the top of stack
			t = t + 1;
			s[t] = i.a;
			break;
		case opr: // math or logical operation
			switch(i.a) {
			case 0: // return after calling function
				t = b - 1;
				p = s[t + 3];
				b = s[t + 2];
				break;
			case 1: // reverse the top of stack
				s[t] = -s[t];
				break;
			case 2: // plus
				t = t - 1;
				s[t] = s[t] + s[t + 1];
				break;
			case 3: // minus
				t = t - 1;
				s[t] = s[t] - s[t + 1];
				break;
			case 4: // times
				t = t - 1;
				s[t] = s[t] * s[t + 1];
				break;
			case 5: // divide
				t = t - 1;
				s[t] = s[t] / s[t + 1];
				break;
			case 6: // odd or even
				s[t] = s[t] % 2;
				break;
			case 8: // ==
				t = t - 1;
				s[t] = (s[t] == s[t + 1])? 1: 0;
				break;
			case 9: // !=
				t = t - 1;
				s[t] = (s[t] != s[t + 1])? 1: 0;
				break;
			case 10: // <
				t = t - 1;
				s[t] = (s[t] < s[t + 1])? 1: 0;
				break;
			case 11: // >=
				t = t - 1;
				s[t] = (s[t] >= s[t + 1])? 1: 0;
			case 12: // >
				t = t - 1;
				s[t] = (s[t] > s[t + 1])? 1: 0;
				break;
			case 13: // <=
				t = t - 1;
				s[t] = (s[t] <= s[t + 1])? 1: 0;
				break;
			case 14: // output the top of stack
				System.out.println(String.valueOf(s[t]));
				fresult.write(String.valueOf(s[t]));
				break;
			case 15: // output \n
				System.out.println("\n");
				//foutput.write("\n");
				fresult.write("\n");
				break;
			case 16: // input a value to the top of stack
				t = t + 1;
				System.out.println("?");
				fresult.write("?");
				Scanner in = new Scanner(System.in);
				if (in.hasNext()) {
					s[t] = in.nextInt();
					fresult.write(String.valueOf(s[t]) + "\n");
				}
				break;
			case 17: // mod
				t = t - 1;
				s[t] = s[t] % s[t + 1];
				break;
			case 18: // xor
				t = t - 1;
				s[t] = ((s[t] != 0) ^ (s[t + 1] != 0))? 1: 0;
				break;
			case 19: // and
				t = t - 1;
				s[t] = ((s[t] != 0) && (s[t + 1] != 0))? 1: 0;
				break;
			case 20: // or
				t = t - 1;
				s[t] = ((s[t] != 0) || (s[t + 1] != 0))? 1: 0;
				break;
			case 21: // not
				s[t] = (!(s[t] != 0))? 1: 0;
				break;
			}
			break;
		case lod: // load the value in a to the top of stack
			t = t + 1;
			s[t] = s[base(i.l, s, b) + i.a];
			break;
		case sto: // store the value on the top of stack into a
			s[base(i.l, s, b) + i.a] = s[t];
			t = t - 1;
			break;
		case cal: // call procedure
			s[t + 1] = base(i.l, s, b); // SL
			s[t + 2] = b; // DL
			s[t + 3] = p; // RA
			b = t + 1;
			p = i.a;
			break;
		case ini: // create n data units space for called procediew
			t = t + i.a;
			break;
		case jmp: // jump directly
			p = i.a;
			break;
		case jpc: // jump when the top of stack is 0 and l is 0 or
			// the top of stack is not 0 and l is 1
			if (s[t] == 0 && i.l == 0) {
				p = i.a;
			}
			else if (s[t] != 0 && i.l == 1) {
				p = i.a;
			}
			t = t - 1;
			break;
		case ext: // exit
			p = 0;
			System.out.println("Exit " + String.valueOf((i.a == 0)? 0: 1) + ".");
			fresult.write("Exit " + String.valueOf((i.a == 0)? 0: 1) + ".");
			break;
		case nul: // do nothing
			break;
		case jpb: // jump both jump to l when the top of stack is 1
			// a when it is 0
			if (s[t] == 0) {
				p = i.a;
			}
			else {
				p = i.l;
			}
			t = t - 1;
			break;
		case dup:
			t = t + 1;
			s[t] = s[t - 1];
			break;
		case era:
			t = t - 1;
			break;
		}
		fresult.flush();
		if (listStackSwitch) {
			liststack(t, s);
		}
	}
}

